<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>multi-swap-hub</title>
    <meta name="description" content="Lovable Generated Project" />
    <meta name="author" content="Lovable" />

    <meta property="og:title" content="multi-swap-hub" />
    <meta property="og:description" content="Lovable Generated Project" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
  </head>

  <body>
    <div id="root"></div>
    <script>
      // IMMEDIATE polyfills - must run before ANY extension code
      (function() {
        'use strict';
        
        // Critical: Define all APIs that wallet extensions might destructure from
        // This must happen IMMEDIATELY to prevent undefined destructuring
        
        // 1. Service Worker API with register method
        if (typeof navigator === 'undefined') {
          globalThis.navigator = {};
        }
        
        var serviceWorkerPolyfill = {
          register: function(scriptURL, options) {
            return Promise.resolve({
              scope: '/',
              installing: null,
              waiting: null,
              active: { state: 'activated' },
              unregister: function() { return Promise.resolve(true); },
              update: function() { return Promise.resolve(); }
            });
          },
          getRegistration: function() { return Promise.resolve(null); },
          getRegistrations: function() { return Promise.resolve([]); },
          ready: Promise.resolve({ active: { state: 'activated' } }),
          controller: null
        };
        
        if (!navigator.serviceWorker) {
          Object.defineProperty(navigator, 'serviceWorker', {
            value: serviceWorkerPolyfill,
            writable: false,
            configurable: false
          });
        }
        
        // 2. Chrome Extension APIs
        var chromePolyfill = {
          runtime: {
            register: function() { return Promise.resolve(); },
            id: 'polyfill-ext',
            onMessage: { addListener: function() {} },
            sendMessage: function() { return Promise.resolve(); },
            connect: function() { 
              return { 
                postMessage: function() {},
                onMessage: { addListener: function() {} },
                onDisconnect: { addListener: function() {} }
              }; 
            }
          },
          storage: {
            local: {
              get: function() { return Promise.resolve({}); },
              set: function() { return Promise.resolve(); }
            }
          }
        };
        
        if (typeof chrome === 'undefined') {
          globalThis.chrome = chromePolyfill;
          if (typeof window !== 'undefined') window.chrome = chromePolyfill;
        }
        
        // 3. Global wallet APIs that extensions might destructure
        var walletAPIs = {
          register: function() { return Promise.resolve(); },
          unregister: function() { return Promise.resolve(); },
          getRegistration: function() { return Promise.resolve(null); }
        };
        
        // Apply to both global and window
        Object.keys(walletAPIs).forEach(function(key) {
          if (typeof globalThis[key] === 'undefined') {
            globalThis[key] = walletAPIs[key];
          }
          if (typeof window !== 'undefined' && typeof window[key] === 'undefined') {
            window[key] = walletAPIs[key];
          }
        });
        
        // 4. Web3 Provider polyfills (common in wallet extensions)
        var web3Provider = {
          register: function() { return Promise.resolve(); },
          isMetaMask: false,
          isPhantom: false,
          request: function() { return Promise.reject(new Error('No wallet connected')); }
        };
        
        if (typeof window !== 'undefined') {
          if (!window.ethereum) window.ethereum = web3Provider;
          if (!window.solana) window.solana = web3Provider;
          if (!window.phantom) window.phantom = { solana: web3Provider };
        }
        
        // 5. Process polyfill (mutable for Vite)
        if (typeof process === 'undefined') {
          globalThis.process = {
            env: {},
            version: '16.0.0',
            platform: 'browser',
            nextTick: function(fn) { setTimeout(fn, 0); }
          };
          if (typeof window !== 'undefined') window.process = globalThis.process;
        }
        
        // 6. Global namespace
        if (typeof global === 'undefined') {
          globalThis.global = globalThis;
        }
        
        // 7. Buffer polyfill
        if (typeof Buffer === 'undefined') {
          var BufferPolyfill = {
            from: function(data, encoding) { 
              if (typeof data === 'string') {
                return new TextEncoder().encode(data);
              }
              if (Array.isArray(data)) {
                return new Uint8Array(data);
              }
              return data instanceof Uint8Array ? data : new Uint8Array(data); 
            },
            isBuffer: function(obj) {
              return obj instanceof Uint8Array;
            },
            alloc: function(size, fill) {
              var buf = new Uint8Array(size);
              if (fill !== undefined) {
                if (typeof fill === 'number') {
                  buf.fill(fill);
                } else if (typeof fill === 'string') {
                  var fillData = new TextEncoder().encode(fill);
                  for (var i = 0; i < size; i++) {
                    buf[i] = fillData[i % fillData.length];
                  }
                }
              }
              return buf;
            },
            allocUnsafe: function(size) {
              return new Uint8Array(size);
            },
            concat: function(buffers, totalLength) {
              if (!Array.isArray(buffers)) return new Uint8Array(0);
              if (totalLength === undefined) {
                totalLength = buffers.reduce(function(sum, buf) { return sum + buf.length; }, 0);
              }
              var result = new Uint8Array(totalLength);
              var offset = 0;
              for (var i = 0; i < buffers.length; i++) {
                var buf = buffers[i];
                result.set(buf, offset);
                offset += buf.length;
              }
              return result;
            },
            compare: function(a, b) {
              if (a.length !== b.length) return a.length - b.length;
              for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return a[i] - b[i];
              }
              return 0;
            }
          };
          globalThis.Buffer = BufferPolyfill;
          if (typeof window !== 'undefined') window.Buffer = BufferPolyfill;
        }
        
      })();
    </script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>